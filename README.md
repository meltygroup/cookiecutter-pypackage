# Cookiecutter PyPackage

[Cookiecutter](https://github.com/audreyr/cookiecutter) template for a
Python application or library.


## Using

To create a project using this template, simply run `cookiecutter`:

```bash
cookiecutter gh:meltygroup/cookiecutter-pypackage
```


## Differences between application and library

Semanticaly: An app can have requirements on libraries, a library can
have requirements on other libraries.

This cookiecutter asks if you're building a library or an application,
both will create a single Python package, with a module in it, the key
difference is the app has no `setup.py` while the library has one.


## Handling requirements

### For applications

If you're doing a Python application should have precise (pinned)
dependencies and sub-dependencies, so you're guaranteed that the
project will work the same for all users, and bug reported by a user
can be consistently reproduced.

Some are doing this using `Pipfile`, but as `pip` has not implemented
`Pipfile` yet, we're achieving this using good old `requirements.txt`
with the help of `pip-compile` from the
[pip-tools](https://github.com/jazzband/pip-tools) project.

We're having 4 versionned files:

- requirements.in
- requirements.txt
- requirements-dev.in
- requirements-dev.txt

`*.in` files contains unpinned (or vaguely pinned) dependencies, like:
```
python-dateutil>=2.0.0
PyJWT
```

`pip-compile` then produce pinned `*.txt` files, the previous `.in`
would be compiled as the following `.txt`:

```
#
# This file is autogenerated by pip-compile
# To update, run:
#
#    pip-compile requirements.in
#
pyjwt==1.7.1
python-dateutil==2.8.0
six==1.12.0               # via python-dateutil
```

As you can see, `pip-compile` pins the subdependencies, so everyone
using your app will have the exact same set of libraries
installed. Also note the nice comments. Again, both files has to be versionned:

- `requirements.in` is the human editable list of dependencies, so you need to keep it.
- `requirements.txt` is what everyone will use to install dependencies, so you need to
  keep it.

Then for the CI to be consistent, it's also nice to pin versions of
linting / testing tools, that's why we have a `requirements-dev.in`
and a `requirements-dev.txt`: just list your test dependencies in
`requirements-dev.in` and "freeze" it using `pip-compile
requirements-dev.in`, tell your CI and developers to use
`requirements-dev.txt` so if tests pass on a machine it will pass
consistently everywhere.


### For a library

A Python library should have broad dependencies to avoid
incompatibilities with other libraries used in a same application.

Imagine an application `App1` having two pinned dependencies as it
should: `lib1==1.0.0` and `lib2==1.0.0`, now imagine `lib1` having a
dependency on `lib3==2.1.13` and `lib2` depending on `lib3==2.1.14`.

This case cannot be solved, you cannot install both `lib3==2.1.13` and
`lib3==2.1.14`, but they are both required. This is sad because I can
bet `lib1` works well with both version of `lib3`, same for `lib2`.

To avoid this we have to accept as our library dependencies the
broadest range of version we know are valid.

So a `setup.py` should look like:

```
    install_requires=["aiohttp>=3.5.4,<4", "defusedxml>=0.5,<1"]
```

In an ideal world you should test if your library still works with
previous versions of `aiohttp` and `defusedxml`, to accept the wider
possible range of versions here.
